<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../fhc-api/fhc-api.html">

<dom-module id="icc-api">
    <template>
        <fhc-api id="fhc-api" host="[[fhcHost]]"></fhc-api>
    </template>
</dom-module>

<script>
    import * as api from 'icc-api/dist/icc-api/iccApi'
    import moment from 'moment/src/moment'

    import {IccBedrugsXApi} from 'icc-api/dist/icc-x-api/icc-bedrugs-x-api'
    import {IccBekmehrXApi} from 'icc-api/dist/icc-x-api/icc-bekmehr-x-api'
    import {IccCodeXApi} from 'icc-api/dist/icc-x-api/icc-code-x-api'
    import {IccContactXApi} from 'icc-api/dist/icc-x-api/icc-contact-x-api'
    import {IccCryptoXApi} from 'icc-api/dist/icc-x-api/icc-crypto-x-api'
    import {IccDocumentXApi} from 'icc-api/dist/icc-x-api/icc-document-x-api'
    import {IccFormXApi} from 'icc-api/dist/icc-x-api/icc-form-x-api'
    import {IccHcpartyXApi} from 'icc-api/dist/icc-x-api/icc-hcparty-x-api'
    import {IccHelementXApi} from 'icc-api/dist/icc-x-api/icc-helement-x-api'
    import {IccPatientXApi} from 'icc-api/dist/icc-x-api/icc-patient-x-api'
    import {IccReceiptXApi} from 'icc-api/dist/icc-x-api/icc-receipt-x-api'
    import {IccUserXApi} from 'icc-api/dist/icc-x-api/icc-user-x-api'
    import {IccInvoiceXApi} from 'icc-api/dist/icc-x-api/icc-invoice-x-api'
    import {IccMessageXApi} from 'icc-api/dist/icc-x-api/icc-message-x-api'

    class IccApi extends Polymer.Element {
        static get is() {
            return 'icc-api'
        }

        static get properties() {
            return {
                headers: {
                    type: Object,
                    value: {"Content-Type": "application/json"},
                    notify: true
                },
                host: {
                    type: String
                },
                fhcHost: {
                    type: String
                },
                baseApi: {
                    type: Object,
                    notify: true
                },
                hcpartyApi: {
                    type: Object
                },
                hcParties: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },
                users: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },
                registry: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },
                sessionId: {
                    type: String
                },

            }
        }

        static get observers() {
            return ["refresh(headers, headers.*, host)"]
        }

        constructor() {
            super()
        }

        ready() {
            super.ready()
            if (this.host != null && this.headers != null) this.refresh()
        }

        refresh() {
            this.accesslogicc = new api.iccAccesslogApi(this.host, this.headers)
            this.authicc = new api.iccAuthApi(this.host, this.headers)
            this.bemikronoicc = new api.iccBemikronoApi(this.host, this.headers)
            this.onlineBeMikronoicc = new api.iccBemikronoApi(this.host && this.host.match(/https:\/\/backend.(.+).icure.cloud.+/) ? this.host : "https://backend.svc.icure.cloud/rest/v1", this.headers)
            this.beresultexporticc = new api.iccBeresultexportApi(this.host, this.headers)
            this.beresultimporticc = new api.iccBeresultimportApi(this.host, this.headers)
            this.doctemplateicc = new api.iccDoctemplateApi(this.host, this.headers)
            this.entitytemplateicc = new api.iccEntitytemplateApi(this.host, this.headers)
            this.genericicc = new api.iccGenericApi(this.host, this.headers)
            this.icureicc = new api.iccIcureApi(this.host, this.headers)
            this.insuranceicc = new api.iccInsuranceApi(this.host, this.headers)
            this.replicationicc = new api.iccReplicationApi(this.host, this.headers)
            this.tarificationicc = new api.iccTarificationApi(this.host, this.headers)
            this.entityreficc = new api.iccEntityrefApi(this.host, this.headers)

            this.calendaritemicc = new api.iccCalendarItemApi(this.host, this.headers)
            this.calendaritemtypeicc = new api.iccCalendarItemTypeApi(this.host, this.headers)

            this.usericc = new IccUserXApi(this.host, this.headers)

            this.codeicc = new IccCodeXApi(this.host, this.headers)
            this.bedrugsicc = new IccBedrugsXApi(this.host, this.headers)

            this.hcpartyiccLight = new api.iccHcpartyApi(this.host, this.headers)
            this.hcpartyicc = new IccHcpartyXApi(this.host, this.headers)

            this.cryptoicc = new IccCryptoXApi(this.host, this.headers, this.hcpartyicc)

            this.receipticc = new IccReceiptXApi(this.host, this.headers, this.cryptoicc)
            this.contacticc = new IccContactXApi(this.host, this.headers, this.cryptoicc)
            this.documenticc = new IccDocumentXApi(this.host, this.headers, this.cryptoicc)
            this.formicc = new IccFormXApi(this.host, this.headers, this.cryptoicc)
            this.helementicc = new IccHelementXApi(this.host, this.headers, this.cryptoicc)
            this.invoiceicc = new IccInvoiceXApi(this.host, this.headers, this.cryptoicc, this.entityreficc)
            this.patienticc = new IccPatientXApi(this.host, this.headers, this.cryptoicc, this.contacticc, this.helementicc, this.invoiceicc, this.documenticc, this.hcpartyicc)
            this.messageicc = new IccMessageXApi(this.host, this.headers, this.cryptoicc, this.insuranceicc, this.entityreficc, this.invoiceicc, this.documenticc, this.receipticc, this.patienticc)
            this.bekmehricc = new IccBekmehrXApi(this.host, this.headers, this.contacticc, this.helementicc)

            this.dispatchEvent(new CustomEvent('refresh', {detail: {}}))
        }

        accesslog() {
            return this.accesslogicc
        }

        entityRef(){
            return this.entityreficc
        }

        auth() {
            return this.authicc
        }

        beab() {
            return this.beabicc
        }

        bechapter() {
            return this.bechaptericc
        }

        bedmg() {
            return this.bedmgicc
        }

        bedrugs() {
            return this.bedrugsicc
        }

        beefact() {
            return this.beefacticc
        }

        beehbox() {
            return this.beehboxicc
        }

        beeid() {
            return this.beeidicc
        }

        beetarif() {
            return this.beetarificc
        }

        begenins() {
            return this.begeninsicc
        }

        behubs() {
            return this.behubsicc
        }

        bekmehr() {
            return this.bekmehricc
        }

        bemikrono() {
            return this.bemikronoicc
        }

        onlinebemikrono(){
            return this.onlineBeMikronoicc
        }

        beprimoto() {
            return this.beprimotoicc
        }

        berecipe() {
            return this.berecipeicc
        }

        beresultexport() {
            return this.beresultexporticc
        }

        beresultimport() {
            return this.beresultimporticc
        }

        bests() {
            return this.bestsicc
        }

        betherlink() {
            return this.betherlinkicc
        }

        bevitalink() {
            return this.bevitalinkicc
        }

        code() {
            return this.codeicc
        }

        contact() {
            return this.contacticc
        }

        doctemplate() {
            return this.doctemplateicc
        }

        document() {
            return this.documenticc
        }

        entitytemplate() {
            return this.entitytemplateicc
        }

        form() {
            return this.formicc
        }

        generic() {
            return this.genericicc
        }

        hcparty() {
            return this.hcpartyicc
        }

        hcpartyLight() {
            return this.hcpartyiccLight
        }

        helement() {
            return this.helementicc
        }

        icure() {
            return this.icureicc
        }

        insurance() {
            return this.insuranceicc
        }

        invoice() {
            return this.invoiceicc
        }

        message() {
            return this.messageicc
        }

        patient() {
            return this.patienticc
        }

        replication() {
            return this.replicationicc
        }

        receipt() {
            return this.receipticc
        }

        tarification() {
            return this.tarificationicc
        }

        user() {
            return this.usericc
        }

        crypto() {
            return this.cryptoicc
        }

        fhc() {
            return this.$['fhc-api'];
        }

        calendaritem(){
            return this.calendaritemicc
        }

        calendaritemtype(){
            return this.calendaritemtypeicc
        }

        localize(e, lng) {
            if (!e) {
                return null;
            }
            return e[lng] || e.fr || e.en || e.nl;
        }

        //Convenience methods for dates management
        after(d1, d2) {
            return d1 === null || d2 === null || d1 === undefined || d2 === undefined || this.moment(d1).isAfter(this.moment(d2));
        }

        before(d1, d2) {
            return d1 === null || d2 === null || d1 === undefined || d2 === undefined || this.moment(d1).isBefore(this.moment(d2));
        }

        moment(epochOrLongCalendar) {
            if (!epochOrLongCalendar && epochOrLongCalendar !== 0) {
                return null;
            }
            if (epochOrLongCalendar >= 18000101 && epochOrLongCalendar < 25400000) {
                return moment('' + epochOrLongCalendar, 'YYYYMMDD');
            } else if (epochOrLongCalendar >= 18000101000000) {
                return moment('' + epochOrLongCalendar, 'YYYYMMDDHHmmss');
            } else {
                return moment(epochOrLongCalendar);
            }
        }

        template(template, args) {
            const nargs = /\{([0-9a-zA-Z_ ]+)\}/g;
            return template.replace(nargs, function replaceArg(match, i, index) {
                var result;

                if (template[index - 1] === "{" && template[index + match.length] === "}") {
                    //Double {{ }} means escape
                    return i;
                } else {
                    result = args.hasOwnProperty(i) ? args[i] : null;
                    if (result === null || result === undefined) {
                        return "";
                    }

                    return result;
                }
            });
        }

        getCurrentAgeFromBirthDate(date, localizer) {

            if(!date) {
                return;
            }

            const birthDate = this.moment(date)
            const now = moment()
            let ageString = ""
            const age = moment.duration(now.diff(birthDate))

            const o = localizer('old','old')
            const ys = localizer('years', 'years')
            const y = localizer('year', 'year')
            const ms = localizer('months', 'months')
            const m = localizer('month', 'month')
            const ws = localizer('weeks', 'weeks')
            const w = localizer('week', 'week')
            const a = localizer('and', 'and')

            if(age.years() < 1) {
                if( (age.years() == 0) && (age.months() + (age.weeks() / 4) <= 1)) {
                    return `${age.weeks()} ${age.weeks() == 1 ? w : ws} ${o}`
                }
                return `${age.months()} ${age.months() == 1 ? m : ms} ${a} ${age.weeks()} ${age.weeks() == 1 ? w : ws} ${o}`
            }else if (age.years() + (age.months() / 12) <= 16) {
                return `${age.years()} ${age.years() == 1 ? y : ys} ${a} ${age.months()} ${age.months() == 1 ? m : ms} ${o}`
            }
            return `${age.years()} ${age.years() == 1 ? y : ys} ${o}`

        }

        getAuthor(author) {
            const usr = this.users[author];
            const hcp = usr ? this.hcParties[usr.healthcarePartyId] : null;
            return hcp && hcp.lastName + " " + (hcp.firstName && hcp.firstName.length && hcp.firstName.substr(0, 1) + ".") || usr && usr.login || "N/A";
        }

        cacheRowsUsingPagination(key, paginator) {
            const cache = this.cache || ((this.cache = {}))
            const promise = cache[key]
            if (promise) { return promise }

            return (cache[key] = this.getRowsUsingPagination(paginator))
        }

        shortLivedCache(key, loader) {
            const cache = this.slCache || ((this.slCache = {}))
            const clean = () => { const now = +new Date(); Object.keys(cache).filter(k =>  cache[k].ttl < now ).forEach(k => delete cache[k]); console.log(`slc: ${cache.length} items`) }
            const wrapper = cache[key]
            if (wrapper) {
                this.cleaner && clearTimeout(this.cleaner)
                this.cleaner = setTimeout(() => clean(), 35000)
                wrapper.ttl = +new Date() + 30000
                return wrapper.promise
            }

            this.cleaner && clearTimeout(this.cleaner)
            this.cleaner = setTimeout(() => clean(), 35000)
            return (cache[key] = {ttl:+new Date() + 30000, promise:loader()}).promise
        }

        getRowsUsingPagination(paginator) {
            const executePaginator = (latestResult, acc) =>
                paginator(latestResult.nextKey,latestResult.nextDocId).then((newResult) => {
                    acc.push(...newResult.rows)
                    return newResult.done ? acc : executePaginator(newResult, acc)
                })
            return executePaginator({nextKey: null, nextDocId: null}, [])
        }

        loadUsersAndHcParties() {
            return this.user().listUsers().then(users => {
                this.set('users', users.rows.reduce((acc, u) => {
                    acc[u.id] = u
                    return acc
                }, {}))
                return Promise.all(_.chunk(users.rows,100).map(uChunk => this.hcparty().getHealthcareParties(uChunk.map(u => u.healthcarePartyId).filter(id => !!id).join(','))))
            }).then(hcps => this.set('hcParties', _.flatMap(hcps).reduce((acc, hcp) => {
                acc[hcp.id] = hcp
                return acc
            }, {}))
            ).catch(() => setTimeout(() => this.loadUsersAndHcParties(), 10000))
        }

        unregisterAll(domain) {
            this.registry[domain] = {listeners:{}, entities:{}, queues: {}}
        }

        getRegistry(domain) {
            return this.registry[domain] || (this.registry[domain] = {listeners: {}, entities: {}, queues: {}})
        }

        /**
         * returns a Promise that will resolve when the current tail of the promise chain for this object resolves or that resolves immediately if the current chain is empty
         *
         * The promise resolves with two args in an array. The one that has been passed to the resolve and the next promise to resolve in order to make the queue advance
         *
         * @param entity
         * @param domain
         * @returns {*}
         */
        queue(entity, domain) {
            if (!entity || !entity.id) { return Promise.resolve([entity, undefined]) }
            const reg = this.getRegistry(domain)

            let res = null
            const defer = new Promise((resolve) => { res = resolve })
            defer.resolve = res

            const thisPromise = reg.queues[entity.id]
            const timeout =  thisPromise ? setTimeout(()=>{ thisPromise.resolve(entity) }, 10000) : null
            reg.queues[entity.id] = defer

            return (thisPromise || Promise.resolve(entity)).then(e =>{ timeout && clearTimeout(timeout); return [e, defer] })
        }

        register(entity, domain, defer) {
            if (!entity || !entity.id) { defer && defer.resolve(entity); return entity }

            const reg = this.getRegistry(domain)
            let current = reg.entities[entity.id]
            if (current && (!current.rev || Number(current.rev.split('-')[0])) <= Number(entity.rev.split('-')[0])) {
                _.difference(_.keys(current), _.keys(entity)).forEach(k => delete current[k])
                _.assign(current, entity)

                Object.values(reg.listeners).forEach(l=>{
                    if (!l.pool || l.pool.some(x => x === entity.id)) {
                        l.paths && l.paths.forEach(path => l.target.notifyPath(path))
                        l.callbacks && l.callbacks.forEach(cb => cb())
                    }
                })
            } else if (!current) {
                current = (reg.entities[entity.id] = entity)
            }

            defer && defer.resolve(current)

            return current
        }

        pdfReport(html, options = {}) {
            const optionsString = _.toPairs(options).map(([k,v]) => `${k}=${v}`).join('&')


            const paperSize = options.paperWidth === 105 ? 'presc' : options.paperHeight === 210 ? 'a5' : 'a4'
            const printersPrefs = JSON.parse(localStorage.getItem('selectedPrinter') || '{}')
            const printerName = printersPrefs[paperSize] && (printersPrefs[paperSize].bw && printersPrefs[paperSize].bw.length ? printersPrefs[paperSize].bw : printersPrefs[paperSize].color && printersPrefs[paperSize].color.length ? printersPrefs[paperSize].color : null) || null

            return (printerName ? Promise.resolve(printerName) : this.printers().then( printers => printers.find(p => p.isDefault)).then(p => p && p.name)).then( printerName => {
                return this.isElectronAvailable().then(electron =>
                    fetch(`${electron && printerName ? 'http://127.0.0.1:16042/print/'+encodeURIComponent(printerName):'https://report.icure.cloud/pdf'}${optionsString && optionsString.length ? `?${optionsString}` : ''}`, {
                        method: "POST",
                        mode: "cors", // no-cors, cors, *same-origin
                        credentials: "same-origin", // include, same-origin, *omit
                        headers: {"Content-Type": "text/html; charset=utf-8"},
                        redirect: "follow",
                        body: html,
                    }).then(response => response.arrayBuffer()).then(data => ({pdf: data, printed: electron && printerName}))
                )
            })
        }

        printers() {
            return this.isElectronAvailable().then(electron =>
                electron && fetch('http://127.0.0.1:16042/printers', { method: "GET" })
                    .then(response => response.json()) || []
            )
        }

        loadBicData() {
            // Already existing, take no action
            if( typeof this.bicsData !== 'undefined' ) return;

            // Doesn't exist yet, require it
            this.bicsData = require('../bic/bics-list.json') || {};
        }

        getBicByIban( inputString ){
            // Get from json file -> casted in this.bicsData
            this.loadBicData();

            // Make sure we've got a string
            inputString = ( inputString || '' ) + '';

            // No Iban ?
            if(!inputString.length) return;

            // First four digits = country code | 3 digits for bic (starting at pos 4) | rest of iban
            var bicCodeToMatchOn = ( inputString.substr( 4, 3 ) );

            // Do we have a candidate ? (3 digits are to be between start & end values)
            var foundResult = _.filter( this.bicsData, o => parseInt( o.startValue ) <= parseInt( bicCodeToMatchOn ) && parseInt( o.endValue ) >= parseInt( bicCodeToMatchOn ) );

            // Up with results, if any
            return foundResult.length ? foundResult[0].bicCode : '';
        }

        logMcn(obj, user, docId, cat, subcat) {
            obj && obj.mycarenetConversation && this.receipticc.logSCReceipt(obj, user, docId, cat, subcat).catch(e => console.log(e))
            return obj
        }

        getUpdatedEdmgStatus( user, patient, requestDate, edmgNiss, edmgOA, genInsOA, genInsAFF, byPassCache=false ){
            if(!user||!patient) return Promise.resolve(null);

            // Everything that isn't today
            this.flushObsoleteEdmgStatusCache();

            const cachedEdmgRespStorageName = 'org.taktik.icure.edmgStatus.' + moment().format('YYYYMMDD') + '.' + user.healthcarePartyId + '.' + patient.ssin;

            // Try to get data from cache
            const cachedEdmgResp = localStorage.getItem( cachedEdmgRespStorageName ) || null;
            if( cachedEdmgResp && !byPassCache ) { return Promise.resolve(JSON.parse(cachedEdmgResp)); }

            if(((edmgNiss && edmgNiss !=='') || (patient.ssin && patient.ssin !== '')) && !(edmgOA && edmgOA !=='')){
                return this.hcparty().getHealthcareParty(user.healthcarePartyId)
                    .then(hcp => {
                        return this.fhc().Dmgcontroller().consultDmgUsingGET(
                            this.keystoreId,
                            this.tokenId,
                            this.credentials.ehpassword,
                            hcp.nihii,
                            hcp.ssin,
                            hcp.firstName,
                            hcp.lastName,
                            edmgNiss ? edmgNiss.trim() : patient.ssin,
                            null,
                            null,
                            null,
                            requestDate
                        ).then( dmgConsult => this.logMcn(dmgConsult, user, patient.id, 'dmg', 'consult'))
                    }).then(edmgResp => {
                        localStorage.setItem( cachedEdmgRespStorageName, JSON.stringify(edmgResp) );
                        return edmgResp||Promise.resolve(null);
                    }).catch(() => { return Promise.resolve(null)});
            }else{
                //there is no niss
                const pi = patient.insurabilities && _.assign({}, patient.insurabilities[0] || {});
                this.insurance().getInsurance(pi.insuranceId).then(insu => {
                    return this.hcparty().getHealthcareParty(user.healthcarePartyId)
                        .then(hcp => {
                                return this.fhc().Dmgcontroller().consultDmgUsingGET(
                                    this.keystoreId,
                                    this.tokenId,
                                    this.credentials.ehpassword,
                                    hcp.nihii,
                                    hcp.ssin,
                                    hcp.firstName,
                                    hcp.lastName,
                                    null,
                                    null,
                                    (genInsOA && genInsOA != '') ? genInsOA.trim() : insu.code,
                                    (genInsAFF && genInsAFF != '') ? genInsAFF.trim() : pi.identificationNumber,
                                    requestDate
                                ).then(dmgConsult => this.logMcn(dmgConsult, user, patient.id, 'dmg', 'consult'))
                            }
                        ).then(edmgResp => {
                            localStorage.setItem( cachedEdmgRespStorageName, JSON.stringify(edmgResp) );
                            return edmgResp||Promise.resolve(null);
                        }).catch(() => { return Promise.resolve(null)});
                    }).catch(() => { return Promise.resolve(null)});
            }

        }

        flushObsoleteEdmgStatusCache() {

            // Target what's for us
            const patternToLookFor= 'org.taktik.icure.edmgStatus.';

            // Loop and drop old ones
            Object.keys(localStorage).filter(k => k.startsWith(patternToLookFor)).forEach(k => {
                // patternToLookFor . YYYYMMDD . userHcpId. patientSsin
                const [dateFormCache] = k.replace(patternToLookFor,'').split('.');

                // Drop if older than today
                if(moment(dateFormCache).isBefore(moment(), 'day')) { localStorage.removeItem(k) }
            });

        }

        triggerFileDownload(fileRawContent, mimeType, downloadFileName, appendTarget = false ) {

            if(!fileRawContent || !_.trim(mimeType) || !_.trim(downloadFileName) ) return;

            let aObject = document.createElement("a");
            let urlObject = window.URL.createObjectURL( new Blob([fileRawContent],{type :mimeType}) );

            (appendTarget?appendTarget:document.body).appendChild( aObject );

            aObject.style = "display: none";
            aObject.href = urlObject;
            aObject.download = downloadFileName;

            aObject.click();

            window.URL.revokeObjectURL(urlObject);
            window.URL.revokeObjectURL(urlObject);

        }

        encryptDecryptFileContentByUserHcpIdAndDocumentObject( encryptOrDecryptMethod, hcpId, documentObject, rawFileContent  ) {
            if( !_.trim(encryptOrDecryptMethod) || !_.trim(hcpId) || !documentObject || !rawFileContent || typeof this.crypto().AES[_.trim(encryptOrDecryptMethod).toLocaleLowerCase()] !== "function" ) return Promise.resolve(rawFileContent);
            return this.crypto().decryptAndImportAesHcPartyKeysInDelegations(hcpId, documentObject.encryptionKeys && Object.keys(documentObject.encryptionKeys).length ? documentObject.encryptionKeys : documentObject.delegations).then(decryptedAndImportedAesHcPartyKeys => {
                let collatedAesKeys = {}; decryptedAndImportedAesHcPartyKeys.map(k => collatedAesKeys[k.delegatorId] = k.key);
                return this.crypto().decryptKeyInDelegationLikes((documentObject.encryptionKeys && Object.keys(documentObject.encryptionKeys).length? documentObject.encryptionKeys: documentObject.delegations)[hcpId], collatedAesKeys, documentObject.id).then(enckeys => {
                    return new Promise((resolve) => { this.crypto().AES[_.trim(encryptOrDecryptMethod).toLocaleLowerCase()](_.get( _.head(decryptedAndImportedAesHcPartyKeys), "key", undefined ), rawFileContent).then(encryptedDecryptedFileContent => resolve(encryptedDecryptedFileContent)) })
                })
            })

        }

        findJsonObjectPathByPropNameAndPropValue( inputData, propName, propValue ) {
          this.variablesPath = []; this.propName = propName; this.propValue = propValue;
          this.browseObject(inputData);
          return this.variablesPath;
        }

        browseObject(inputData, sub="") {
            if (inputData && typeof inputData === "object") {
              if (Array.isArray(inputData)) { for (let i = 0; i < inputData.length; i++) { this.browseObject(inputData[i], sub + "[" + i + "]"); }
              } else {
                for (let p in inputData) {
                    if ((/^[a-z_$][a-z0-9_$]*$/i).test(p)) {
                        this.browseObject(inputData[p], sub + "." + p);
                        if(p===this.propName && inputData[p] === this.propValue ) { this.variablesPath.push(sub.substr(1)); }
                    } else {
                        this.browseObject(inputData[p], sub + "[\"" + p + "\"]");
                    }
                }
              }
            }
        }

        rewriteTableColumnsWidth(inputContent) {
            // Ratio between prose editor doc width and A4 pdf impression
            const ratioFactor = 1.39;
            // Col group has column width definitions, in relative pxs
            (inputContent.match(/<col style="([^"]*)">/gi)||[]).map(tagMatch=>{
                (tagMatch.match(/(width:)(\s*)([\d]*)(px)/gi)||[]).map(widthMatch=>{
                    (widthMatch.match(/(\d*)/gi)||[]).map(widthValue=>{
                        if(parseInt(widthValue)) { inputContent = inputContent.replace( tagMatch, tagMatch.replace(widthMatch, widthMatch.replace(widthValue, Math.floor(widthValue*ratioFactor) ) ) ); }
                    });
                });
            })
            return inputContent;
        }

        formatInamiNumber(inputContent) {
            // Split with hyphens (1,6,2,3) unless already has some or is empty
            return inputContent.indexOf("-")>-1 || !_.trim(inputContent) ? inputContent : _.trim([inputContent.slice(0,1),inputContent.slice(1,6),inputContent.slice(6,8),inputContent.slice(8,11)].join("-"));
        }

        formatSsinNumber(inputContent) {
            inputContent = _.trim(inputContent).replace(/[^0-9]+/g, '')
            return _.trim([inputContent.slice(0,2),inputContent.slice(2,4),inputContent.slice(4,6)].join(".")) + "-" + _.trim([inputContent.slice(6,9),inputContent.slice(9,11)].join("."));
        }

        isElectronAvailable() {
            return fetch(`http://127.0.0.1:16042/ok`, {
                method: "GET"
            })
                .then(() => true)
                .catch(() => false)
        }
    }

    customElements.define(IccApi.is, IccApi)
</script>

@end


